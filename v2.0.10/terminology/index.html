<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Terminology · NaiveNASlib</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NaiveNASlib</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../examples/quicktutorial/">Quick Tutorial</a></li><li><a class="tocitem" href="../examples/advancedtutorial/">Advanced Tutorial</a></li><li class="is-active"><a class="tocitem" href>Terminology</a><ul class="internal"><li><a class="tocitem" href="#Graph"><span>Graph</span></a></li><li><a class="tocitem" href="#Vertex"><span>Vertex</span></a></li><li><a class="tocitem" href="#Edge"><span>Edge</span></a></li><li><a class="tocitem" href="#Neuron"><span>Neuron</span></a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../reference/simple/createvertex/">Vertex Creation</a></li><li><a class="tocitem" href="../reference/simple/graph/">Graph Operations</a></li><li><a class="tocitem" href="../reference/simple/queryvertex/">Access vertex data</a></li><li><a class="tocitem" href="../reference/simple/mutatevertex/">Vertex Mutation</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reference/advanced/graphquery/">Advanced Graph Functions</a></li><li><a class="tocitem" href="../reference/advanced/size/">Size Strategies</a></li><li><a class="tocitem" href="../reference/advanced/structure/">Vertex Connection Strategies</a></li><li><a class="tocitem" href="../reference/advanced/traits/">Extra Vertex Traits</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Extend</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reference/extend/vertices/">Vertex Types</a></li><li><a class="tocitem" href="../reference/extend/strategies/">Strategy Base Types</a></li><li><a class="tocitem" href="../reference/extend/traits/">Trait Types</a></li><li><a class="tocitem" href="../reference/extend/misc/">Other Functions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Terminology</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Terminology</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DrChainsaw/NaiveNASlib.jl/blob/master/docs/src/terminology.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Terminology"><a class="docs-heading-anchor" href="#Terminology">Terminology</a><a id="Terminology-1"></a><a class="docs-heading-anchor-permalink" href="#Terminology" title="Permalink"></a></h1><p>NaiveNASlib tries to use standard graph and neural network terminology to whatever extent possible. Here is a short summary of the  important concepts and what they mean to NaiveNASlib. This section is best read after the <a href="../examples/quicktutorial/#Quick-Tutorial">Quick Tutorial</a> to make  it somewhat more concrete.</p><h2 id="Graph"><a class="docs-heading-anchor" href="#Graph">Graph</a><a id="Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Graph" title="Permalink"></a></h2><p>Since the only types of graphs NaiveNASlib cares about are directed acyclic graphs which describe the data flow through a  function, the term &#39;graph&#39; is often used interchangeably with terms like &#39;model&#39;, &#39;function&#39; and &#39;neural network&#39;.</p><p>Furthermore, due to how vertices in NaiveNASlib also contain their <a href="#Edge">edges</a>, a single vertex from a graph recursively describes the whole graph.</p><h2 id="Vertex"><a class="docs-heading-anchor" href="#Vertex">Vertex</a><a id="Vertex-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex" title="Permalink"></a></h2><p>Vertices are the fundamental unit which NaiveNASlib works with when changing the structure of a graph. A vertex can be queried for both input and output vertices as well as its current input and output size (see <a href="#Neuron">Neuron</a> below). </p><p>Most vertices in the graph wrap a function which from the point of view of NaiveNASlib are the primitives of the computation  graph. NaiveNASlib does not have a firm opinion on what functions are considered primitive though. One vertex in the graph can wrap a single layer (or something even simpler) while another can wrap a whole computation graph.</p><p>As seen in the <a href="../examples/quicktutorial/#Quick-Tutorial">Quick Tutorial</a>, how to adjust the input/output sizes of the vertices in the graph depends on the  computation.</p><p>NaiveNASlib uses traits to classify three basic types of vertices so that it does not have to implement rules for every possible primitive. The core idea of NaiveNASlib is basically to annotate the type of vertex in the graph so that it knows  what is the proper way to deal with the neighboring vertices when mutating a vertex.</p><p>This is done through labeling vertices into three major types:</p><ul><li><p><a href="../reference/extend/traits/#NaiveNASlib.SizeAbsorb"><code>SizeAbsorb</code></a>: Assumes <a href="../reference/simple/queryvertex/#NaiveNASlib.nout"><code>nout(v)</code></a> and <a href="../reference/simple/queryvertex/#NaiveNASlib.nin"><code>nin(v)</code></a> may change independently. This means that size changes   are absorbed by this vertex in the sense they don&#39;t propagate further. Most typical neural network layers with parameter   arrays fall into this category.</p></li><li><p><a href="../reference/extend/traits/#NaiveNASlib.SizeStack"><code>SizeStack</code></a>: Assumes <a href="../reference/simple/queryvertex/#NaiveNASlib.nout"><code>nout(v)</code></a> <code>==</code> <a href="../reference/simple/queryvertex/#NaiveNASlib.nin"><code>sum(nin(v))</code></a>. This means that size changes propagate forwards (i.e. input -&gt; output and   output -&gt; input). The main operation in this category is concatenation of activations. </p></li><li><p><a href="../reference/extend/traits/#NaiveNASlib.SizeInvariant"><code>SizeInvariant</code></a>: Assumes <a href="../reference/simple/queryvertex/#NaiveNASlib.nout"><code>[nout(v)]</code></a> <code>==</code> <a href="../reference/simple/queryvertex/#NaiveNASlib.nin"><code>unique(nin(v))</code></a>. This means that size changes propagate both forwards and backwards   as changing any input size or the output size means all others must change as well. In this category we typically find element wise operations, but also normalization and pooling operations tend to fall into this category. </p></li></ul><p>NaiveNASlib also uses the term <a href="../reference/extend/traits/#NaiveNASlib.SizeTransparent"><code>SizeTransparent</code></a> to denote the latter two (i.e any vertex which is not <a href="../reference/extend/traits/#NaiveNASlib.SizeAbsorb"><code>SizeAbsorb</code></a>). To use this library to mutate architectures for some neural network library basically means annotating up the above type for  each layer type and connect parameter dimensions to input and output sizes.</p><p>Note one typically does not need to interact with the traits when just using NaiveNASlib and they are not exported by default. The functions for <a href="../reference/simple/createvertex/#Vertex-Creation">Vertex Creation</a> attaches the proper trait to the vertex when creating it.</p><p>While the above covers a substantial set of operations, it is possible to implement special rules for individual computations as well.</p><h2 id="Edge"><a class="docs-heading-anchor" href="#Edge">Edge</a><a id="Edge-1"></a><a class="docs-heading-anchor-permalink" href="#Edge" title="Permalink"></a></h2><p>Contrary to more general graph frameworks, edges in NaiveNASlib are implicit in the sense that each vertex stores its input  and output vertices. Edges are primarily used when evaluating the graph as a function as well as when formulating the  constraints for keeping the graph size aligned.</p><p>While this is typically seen as impractical in more general graph analyzing frameworks, the scope of NaiveNASlib makes this a relatively sane choice as it allows for the convenience of passing a single vertex to mutating functions without having to haul around the whole graph object.</p><h2 id="Neuron"><a class="docs-heading-anchor" href="#Neuron">Neuron</a><a id="Neuron-1"></a><a class="docs-heading-anchor-permalink" href="#Neuron" title="Permalink"></a></h2><p>Neuron is the name NaiveNASlib uses for the indices of the relevant dimension of the arrays passed between vertices. For example, if one vertex <code>v</code> takes a vector of size <code>N</code> as input and returns a vector of size <code>M</code> it has <code>N</code> input neurons and <code>M</code> output neurons. This is synonymous with saying that <code>v</code> has input size <code>N</code> and output size <code>M</code> and <a href="../reference/simple/queryvertex/#NaiveNASlib.nin"><code>nin(v)</code></a> <code>== N</code> and <a href="../reference/simple/queryvertex/#NaiveNASlib.nout"><code>nout(v)</code></a> <code>== M</code>.</p><p>When changing input or output size <code>v</code> will be given indices of the neurons to keep as well as where to insert new neurons. NaiveNASlib has then made sure that other vertices have gotten indices so that all remaining  neurons stay connected to the same neurons they were connected to previously. See <a href="../examples/quicktutorial/#Closer-look-at-how-weights-are-modified">Closer look at how weights are modified</a> for a concrete example.</p><p>NaiveNASlib does not have the ability to figure out what input and output sizes a function wrapped in a vertex have by itself, so this must be provided by the implementation. See <a href="../reference/simple/queryvertex/#NaiveNASlib.nout"><code>nout</code></a> and <a href="../reference/simple/queryvertex/#NaiveNASlib.nin"><code>nin</code></a>.</p><p>Examples of how to determine the input and output size for common layer types:</p><ul><li>Fully connected layers: The size of the non-batch dimension, typically the rows/columns of the weight matrix.</li><li>Recurrent layers: The size of the dimension which is neither batch nor time. </li><li>Convolutional layers: The number of input/output channels. </li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/advancedtutorial/">« Advanced Tutorial</a><a class="docs-footer-nextpage" href="../reference/simple/createvertex/">Vertex Creation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 28 April 2023 20:27">Friday 28 April 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

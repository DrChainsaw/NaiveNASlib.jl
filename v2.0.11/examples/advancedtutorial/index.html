<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Tutorial · NaiveNASlib</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NaiveNASlib</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../quicktutorial/">Quick Tutorial</a></li><li class="is-active"><a class="tocitem" href>Advanced Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Strategies"><span>Strategies</span></a></li><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#Graph-instrumentation-and-modification"><span>Graph instrumentation and modification</span></a></li></ul></li><li><a class="tocitem" href="../../terminology/">Terminology</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../reference/simple/createvertex/">Vertex Creation</a></li><li><a class="tocitem" href="../../reference/simple/graph/">Graph Operations</a></li><li><a class="tocitem" href="../../reference/simple/queryvertex/">Access vertex data</a></li><li><a class="tocitem" href="../../reference/simple/mutatevertex/">Vertex Mutation</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Advanced</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/advanced/graphquery/">Advanced Graph Functions</a></li><li><a class="tocitem" href="../../reference/advanced/size/">Size Strategies</a></li><li><a class="tocitem" href="../../reference/advanced/structure/">Vertex Connection Strategies</a></li><li><a class="tocitem" href="../../reference/advanced/traits/">Extra Vertex Traits</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Extend</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/extend/vertices/">Vertex Types</a></li><li><a class="tocitem" href="../../reference/extend/strategies/">Strategy Base Types</a></li><li><a class="tocitem" href="../../reference/extend/traits/">Trait Types</a></li><li><a class="tocitem" href="../../reference/extend/misc/">Other Functions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Advanced Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DrChainsaw/NaiveNASlib.jl/blob/master/test/examples/advancedtutorial.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-Tutorial"><a class="docs-heading-anchor" href="#Advanced-Tutorial">Advanced Tutorial</a><a id="Advanced-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Tutorial" title="Permalink"></a></h1><p>The previous examples have been focused on giving an overview of the purpose of this library using the simple high level API. For more advanced usage, there are many of ways to customize the behavior and in other ways alter or hook in to the functionality. Some of the more important concepts are described below.</p><p>To make it more convenient to extend <code>NaiveNASlib</code>, the two submodules <code>NaiveNASlib.Advanced</code> and <code>NaiveNASlib.Extend</code> export most of the useful stuff, such as abstract types and composable strategies. For now they are also part of the public API, but in future releases they might be moved to separate subpackages so that they can be versioned separately (e.g NaiveNASlibCore).</p><pre><code class="language-julia hljs">using NaiveNASlib.Advanced, NaiveNASlib.Extend</code></pre><h2 id="Strategies"><a class="docs-heading-anchor" href="#Strategies">Strategies</a><a id="Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Strategies" title="Permalink"></a></h2><p>For more or less all operations which mutate the graph, it is possible achieve fine grained control of the operation through selecting a strategy.</p><p>Here is an example of strategies for changing the size.</p><p>First we make a simple graph where one vertex has a constraint for changing the size.</p><pre><code class="language-julia hljs">invertex = inputvertex(&quot;in&quot;, 3)
layer1 = linearvertex(invertex, 4)
joined = conc(scalarmult(layer1, 2), scalarmult(layer1, 3), dims=1)</code></pre><p>Note that <code>joined</code> can only change in steps of 2.</p><p>Strategy to try to change it by one and throw an error when not successful.</p><pre><code class="language-julia hljs">exact_or_fail = ΔNoutExact(joined =&gt; 1; fallback=ThrowΔSizeFailError(&quot;Size change failed!!&quot;))</code></pre><p>Note that we now call <a href="../../reference/extend/misc/#NaiveNASlib.Δsize!-Tuple{Any, AbstractVector{T} where T, AbstractVector{T} where T}"><code>Δsize!</code></a> instead of <a href="../../reference/simple/mutatevertex/#NaiveNASlib.Δnout!"><code>Δnout!</code></a> as the wanted action is given by the strategy.</p><pre><code class="language-julia hljs">@test_throws NaiveNASlib.ΔSizeFailError Δsize!(exact_or_fail)
@test nout(joined) == 2*nout(layer1) == 8 # No change was made.</code></pre><p>Try to change by one and fail silently when not successful.</p><pre><code class="language-julia hljs">exact_or_noop = ΔNoutExact(joined=&gt;1;fallback=ΔSizeFailNoOp())

@test !Δsize!(exact_or_noop)
@test nout(joined) == 2*nout(layer1) == 8 # No change was made.</code></pre><p>In many cases it is ok to not get the exact change which was requested.</p><pre><code class="language-julia hljs">relaxed_or_fail = ΔNoutRelaxed(joined=&gt;1;fallback=ThrowΔSizeFailError(&quot;This should not happen!!&quot;))

@test Δsize!(relaxed_or_fail)
# Changed by two as this was the smallest possible change.
@test nout(joined) == 2*nout(layer1) == 10</code></pre><p>Logging when fallback is applied is also possible.</p><pre><code class="language-julia hljs">using Logging: Info
exact_or_log_then_relax = ΔNoutExact(joined=&gt;1;
                                        fallback=LogΔSizeExec(
                                                        &quot;Exact failed, relaxing&quot;,
                                                        Info,
                                                        relaxed_or_fail))

@test_logs (:info, &quot;Exact failed, relaxing&quot;) Δsize!(exact_or_log_then_relax)
@test nout(joined) == 2*nout(layer1) == 12</code></pre><p>If one wants to see every size change we can set up an <a href="../../reference/advanced/size/#NaiveNASlib.AfterΔSizeCallback"><code>AfterΔSizeCallback</code></a> strategy to log it for us like this:</p><pre><code class="language-julia hljs">exact_or_log_then_relax_verbose = logafterΔsize(v -&gt; &quot;some vertex&quot;;base=exact_or_log_then_relax)

@test_logs(
    (:info, &quot;Exact failed, relaxing&quot;),
    (:info, r&quot;Change nin of some vertex&quot;),
    (:info, r&quot;Change nout of some vertex&quot;),
    match_mode=:any,
    Δsize!(exact_or_log_then_relax_verbose))</code></pre><p>A similar pattern is used for most other mutating operations. See the advanced reference documentation for the complete set.</p><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><p>A variant (bastardization?) of the <a href="https://docs.julialang.org/en/v1/manual/methods/#Trait-based-dispatch-1">holy trait</a> pattern is used to annotate the type of a vertex. The core idea is discussed a bit in the <a href="../../terminology/#Terminology">Terminology</a> section, but it is also possible to attach other information and behaviors by freeriding on this mechanism.</p><p>This is done by adding the argument <code>traitdecoration</code> when creating a vertex and supplying a function which takes a trait and return a new trait (which typically wraps the input).</p><p>Naming vertices is so useful for logging and debugging I almost made it mandatory.</p><p>If a vertex does not have the named trait, <a href="../../reference/simple/queryvertex/#NaiveNASlib.name"><code>name</code></a> will return a generic string. Compare</p><pre><code class="language-julia hljs">noname = linearvertex(inputvertex(&quot;in&quot;, 2), 2)
@test name(noname) == &quot;MutationVertex::SizeAbsorb&quot;</code></pre><p>with</p><pre><code class="language-julia hljs">hasname = absorbvertex(LinearLayer(2, 3), inputvertex(&quot;in&quot;, 2), traitdecoration = t -&gt; NamedTrait(&quot;named layer&quot;, t))
@test name(hasname) == &quot;named layer&quot;</code></pre><p>which is basically what the convenience methods do under the hood.</p><pre><code class="language-julia hljs">hasnametoo = absorbvertex(&quot;also named&quot;, LinearLayer(2, 3), inputvertex(&quot;in&quot;, 2))
@test name(hasnametoo) == &quot;also named&quot;</code></pre><p><a href="../../reference/advanced/traits/#NaiveNASlib.AfterΔSizeTrait"><code>AfterΔSizeTrait</code></a> can be used to attach an <a href="../../reference/extend/strategies/#NaiveNASlib.AbstractAfterΔSizeStrategy"><code>AbstractAfterΔSizeStrategy</code></a> to an individual vertex. In this case we use <a href="../../reference/advanced/size/#NaiveNASlib.logafterΔsize"><code>logafterΔsize</code></a> from the example above.</p><pre><code class="language-julia hljs">verbose_vertex_info(v) = string(name(v),
                                 &quot; with inputs=[&quot;, join(name.(inputs(v)),  &quot;, &quot;),
                                &quot;] and outputs=[&quot;, join(name.(outputs(v)), &quot;, &quot;), &#39;]&#39;)
named_verbose_logging(t) = AfterΔSizeTrait(
                                        logafterΔsize(verbose_vertex_info),
                                        NamedTrait(&quot;layer1&quot;, t))
layer1 = absorbvertex(  LinearLayer(2, 3),
                        inputvertex(&quot;in&quot;, 2),
                        traitdecoration = named_verbose_logging)</code></pre><p>The above is a mouthful, but <code>NaiveNASlib.Advanced</code> exports the <a href="../../reference/advanced/traits/#NaiveNASlib.named"><code>named</code></a> and <a href="../../reference/advanced/traits/#NaiveNASlib.logged"><code>logged</code></a> functions for convenience</p><pre><code class="language-julia hljs">layer2 = absorbvertex(  LinearLayer(nout(layer1), 4),
                        layer1;
                        traitdecoration = logged(name) ∘ named(&quot;layer2&quot;))</code></pre><p>Now logs for <code>layer2</code> are less verbose than logs for <code>layer1</code> due to <code>name</code> being used to print the vertex instead of <code>verbose_vertex_info</code>.</p><pre><code class="language-julia hljs">@test_logs(
(:info, &quot;Change nout of layer1 with inputs=[in] and outputs=[layer2] by [1, 2, 3, -1]&quot;),
(:info, &quot;Change nin of layer2 by [1, 2, 3, -1]&quot;),
Δnout!(layer1, 1))</code></pre><p>For more elaborate traits with elementwise operations one can use traitconf and <code>&gt;&gt;</code>.</p><pre><code class="language-julia hljs">add = traitconf(logged(verbose_vertex_info) ∘ named(&quot;layer1+layer2&quot;)) &gt;&gt; layer1 + layer2
@test name(add) == &quot;layer1+layer2&quot;

@test_logs(
(:info, &quot;Change nout of layer1 with inputs=[in] and outputs=[layer2, layer1+layer2] by [1, 2, 3, 4, -1]&quot;),
(:info, &quot;Change nin of layer2 by [1, 2, 3, 4, -1]&quot;),
(:info, &quot;Change nout of layer2 by [1, 2, 3, 4, -1]&quot;),
(:info, &quot;Change nin of layer1+layer2 with inputs=[layer1, layer2] and outputs=[] by [1, 2, 3, 4, -1] and [1, 2, 3, 4, -1]&quot;),
(:info, &quot;Change nout of layer1+layer2 with inputs=[layer1, layer2] and outputs=[] by [1, 2, 3, 4, -1]&quot;),
Δnout!(layer1, 1))</code></pre><p>When creating own trait wrappers, remember to subtype <a href="../../reference/extend/traits/#NaiveNASlib.DecoratingTrait"><code>DecoratingTrait</code></a> or else there will be pain.</p><pre><code class="language-julia hljs">struct PainfulTrait{T&lt;:MutationTrait} &lt;: MutationTrait
    base::T
end
painlayer = absorbvertex(   LinearLayer(2, 3),
                            inputvertex(&quot;in&quot;, 2);
                            traitdecoration = PainfulTrait)</code></pre><p>Wrong! Not a subtype of <a href="../../reference/extend/traits/#NaiveNASlib.DecoratingTrait"><code>DecoratingTrait</code></a>.</p><pre><code class="language-julia hljs">@test_throws MethodError Δnout!(painlayer, 1)</code></pre><p>Now one must implement a lot of methods for <code>PainfulTrait</code>...</p><p>Lets try that again:</p><pre><code class="language-julia hljs">struct SmoothSailingTrait{T&lt;:MutationTrait} &lt;: DecoratingTrait
    base::T
end</code></pre><p>Right! Is a subtype of <a href="../../reference/extend/traits/#NaiveNASlib.DecoratingTrait"><code>DecoratingTrait</code></a>. Just implement <a href="../../reference/extend/traits/#NaiveNASlib.base-Tuple{DecoratingTrait}"><code>base</code></a> and all will be fine.</p><pre><code class="language-julia hljs">NaiveNASlib.base(t::SmoothSailingTrait) = t.base

smoothlayer = absorbvertex( LinearLayer(2, 3),
                            inputvertex(&quot;in&quot;, 2);
                            traitdecoration = SmoothSailingTrait)

@test Δnout!(smoothlayer, 1)
@test nout(smoothlayer) == 4</code></pre><h2 id="Graph-instrumentation-and-modification"><a class="docs-heading-anchor" href="#Graph-instrumentation-and-modification">Graph instrumentation and modification</a><a id="Graph-instrumentation-and-modification-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-instrumentation-and-modification" title="Permalink"></a></h2><p>In many cases it is desirable to change things like traits of an existing graph. This can be achieved through <a href="https://github.com/FluxML/Functors.jl">Functors.jl</a>, often through clever usage of the <code>walk</code> function.</p><p>Depending on what one wants to achieve, it can be more or less messy. Here is a pretty messy example:</p><pre><code class="language-julia hljs">invertex = inputvertex(&quot;in&quot;, 2)
layer1 = linearvertex(invertex, 3)
layer2 = linearvertex(layer1, 4)

graph = CompGraph(invertex, layer2)

@test name.(vertices(graph)) == [&quot;in&quot;, &quot;MutationVertex::SizeAbsorb&quot;, &quot;MutationVertex::SizeAbsorb&quot;]</code></pre><p>Ok, lets add names to <code>layer1</code> and <code>layer2</code> and change the name of <code>invertex</code> by using <code>Functors</code>.</p><pre><code class="language-julia hljs">import Functors

struct RenameWalk &lt;: Functors.AbstractWalk end</code></pre><p>Always used CachedWalk on CompGraphs and vertices!!</p><pre><code class="language-julia hljs">walk = Functors.CachedWalk(RenameWalk())</code></pre><p>Add a name to <code>layer1</code> and <code>layer2</code></p><pre><code class="language-julia hljs">function (::RenameWalk)(recurse, v::MutationVertex)
    # This is probably not practical to do in a real graph, so make sure you have names when first creating it...
    name = v == layer1 ? &quot;layer1&quot; : &quot;layer2&quot;
    addname(x) = x
    # SizeAbsorb has no fields, otherwise we would have had to use walk to wrap it
    addname(t::SizeAbsorb) = NamedTrait(name, t)
    Functors.DefaultWalk()(v) do x
        Functors.fmap(addname, x; walk, cache=nothing)
    end
end</code></pre><p>Change name of <code>invertex</code> once we get there. We could also just have made a string version of <code>addname</code> above since there are no other strings in the graph, but this is safer.</p><pre><code class="language-julia hljs">function (::RenameWalk)(recurse, v::InputVertex)
    rename(x) = x
    rename(s::String) = &quot;in changed&quot;
    Functors.DefaultWalk()(v) do x
        Functors.fmap(rename, x; walk, cache=nothing)
    end
end</code></pre><p>Everything else just gets functored as normal.</p><pre><code class="language-julia hljs">(::RenameWalk)(recurse, x) = Functors.DefaultWalk()(recurse, x)</code></pre><p>I must admit that thinking about what this does makes me a bit dizzy...</p><pre><code class="language-julia hljs">namedgraph = Functors.fmap(walk, identity, graph)

@test name.(vertices(namedgraph)) == [&quot;in changed&quot;, &quot;layer1&quot;, &quot;layer2&quot;]
@test graph(ones(2, 1)) == namedgraph(ones(2,1))</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quicktutorial/">« Quick Tutorial</a><a class="docs-footer-nextpage" href="../../terminology/">Terminology »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 7 August 2023 07:28">Monday 7 August 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
